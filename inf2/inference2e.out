
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> RigidObject(skc6)*.
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
5[0:Inp] || Leq(U,V)* Time(U) Time(V) -> Ordered(U,V).
6[0:Inp] || Leq(U,V)* Time(V) Time(U) -> Ordered(V,U).
7[0:Inp] || Ordered(U,V) Time(U) Time(V) -> Leq(U,V)* Leq(V,U)*.
8[0:Inp] || CContained(U,V,Singleton(W))* RigidObject(W) Lt(U,X)* -> CContained(X,V,Singleton(W))*.
9[0:Inp] || CContained(U,V,Singleton(W))* RigidObject(W) Lt(X,U)* -> CContained(X,V,Singleton(W))*.
 This is a first-order Non-Horn problem without equality.
 This is a problem that contains sort information.
 The conjecture is ground.
 The following monadic predicates have finite extensions: RigidObject.
 Axiom clauses: 5 Conjecture clauses: 4
 Inferences: IEmS=1 ISoR=1 IORe=1 IOFc=1 
 Reductions: RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSST=1 RSSi=1 RFSub=1 RBSub=1 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: Singleton > HPlace > RUnion > Place > Slice > Leq > Ordered > Time > CContained > RigidObject > Contained > Region > History > Object > ObjectSet > Lt > Leq3 > P > Cavity > OSPlace > ClosedContainer > RigidHistory > O > EC > DR > Outside > Os2 > Ob2a > Ob2b > Ta2 > Tb2 > skc0 > skc1 > skc2 > skc3 > skc4 > skc5 > skc6 > skc7
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
1[0:Inp] ||  -> RigidObject(skc6)*.
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
21[0:Res:3.0,20.0] || Lt(skc5,skc4)* -> .
22[0:Res:3.0,19.0] || Lt(skc4,skc5)* -> .
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
17[0:MRR:13.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
18[0:MRR:14.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
20[0:MRR:16.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
19[0:MRR:15.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
12[0:Res:2.0,7.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4) Leq(skc4,skc5)*.
6[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
5[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
10[0:Res:1.0,8.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))* -> CContained(V,W,Singleton(skc6))*.
11[0:Res:1.0,9.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))* -> CContained(U,W,Singleton(skc6))*.
7[0:Inp] Time(U) Time(V) || Ordered(V,U) -> Leq(U,V)* Leq(V,U)*.
9[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))* -> CContained(V,X,Singleton(U))*.
8[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))* -> CContained(W,X,Singleton(U))*.
	Given clause: 1[0:Inp] ||  -> RigidObject(skc6)*.
	Given clause: 2[0:Inp] ||  -> Ordered(skc4,skc5)*.
	Given clause: 21[0:Res:3.0,20.0] || Lt(skc5,skc4)* -> .
	Given clause: 22[0:Res:3.0,19.0] || Lt(skc4,skc5)* -> .
	Given clause: 3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
	Given clause: 4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
	Given clause: 17[0:MRR:13.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
	Given clause: 18[0:MRR:14.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
	Given clause: 20[0:MRR:16.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
	Given clause: 6[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
	Given clause: 29[0:Res:18.1,20.1] || Lt(U,skc4)*+ Lt(skc5,U)* -> .
	Given clause: 30[0:Res:17.1,20.1] || Lt(skc4,U)* Lt(skc5,U) -> .
	Given clause: 19[0:MRR:15.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
	Given clause: 32[0:Res:18.1,19.1] || Lt(U,skc4)* Lt(U,skc5) -> .
	Given clause: 5[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
	Given clause: 33[0:Res:17.1,19.1] || Lt(skc4,U)*+ Lt(U,skc5)* -> .
	Given clause: 12[0:Res:2.0,7.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4) Leq(skc4,skc5)*.
	Given clause: 10[0:Res:1.0,8.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))*+ -> CContained(V,W,Singleton(skc6))*.
	Given clause: 35[0:Res:18.1,10.1] || Lt(U,skc4)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 7[0:Inp] Time(U) Time(V) || Ordered(V,U)+ -> Leq(U,V)* Leq(V,U)*.
	Given clause: 36[0:Res:17.1,10.1] || Lt(skc4,U)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 11[0:Res:1.0,9.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))*+ -> CContained(U,W,Singleton(skc6))*.
	Given clause: 39[0:Res:18.1,11.1] || Lt(U,skc4)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 40[0:Res:17.1,11.1] || Lt(skc4,U)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 9[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))*+ -> CContained(V,X,Singleton(U))*.
	Given clause: 8[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))*+ -> CContained(W,X,Singleton(U))*.
SPASS V 3.5 
SPASS beiseite: Completion found.
Problem: inference2e.dfg 
SPASS derived 32 clauses, backtracked 0 clauses, performed 0 splits and kept 26 clauses.
SPASS allocated 52226 KBytes.
SPASS spent	0:00:00.02 on the problem.
		0:00:00.01 for the input.
		0:00:00.01 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


 The saturated set of worked-off clauses is :
8[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))*+ -> CContained(W,X,Singleton(U))*.
9[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))*+ -> CContained(V,X,Singleton(U))*.
40[0:Res:17.1,11.1] || Lt(skc4,U)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
39[0:Res:18.1,11.1] || Lt(U,skc4)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
11[0:Res:1.0,9.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))*+ -> CContained(U,W,Singleton(skc6))*.
36[0:Res:17.1,10.1] || Lt(skc4,U)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
7[0:Inp] Time(U) Time(V) || Ordered(V,U)+ -> Leq(U,V)* Leq(V,U)*.
35[0:Res:18.1,10.1] || Lt(U,skc4)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
10[0:Res:1.0,8.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))*+ -> CContained(V,W,Singleton(skc6))*.
12[0:Res:2.0,7.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4) Leq(skc4,skc5)*.
33[0:Res:17.1,19.1] || Lt(skc4,U)*+ Lt(U,skc5)* -> .
5[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
32[0:Res:18.1,19.1] || Lt(U,skc4)* Lt(U,skc5) -> .
19[0:MRR:15.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
30[0:Res:17.1,20.1] || Lt(skc4,U)* Lt(skc5,U) -> .
29[0:Res:18.1,20.1] || Lt(U,skc4)*+ Lt(skc5,U)* -> .
6[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
20[0:MRR:16.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
18[0:MRR:14.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
17[0:MRR:13.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
22[0:Res:3.0,19.0] || Lt(skc4,skc5)* -> .
21[0:Res:3.0,20.0] || Lt(skc5,skc4)* -> .
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
1[0:Inp] ||  -> RigidObject(skc6)*.
--------------------------SPASS-STOP------------------------------
