
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> RigidObject(skc6)*.
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
5[0:Inp] || Lt(U,V) Time(U) Time(V) -> Leq(U,V)*.
6[0:Inp] || equal(U,V) Time(U) Time(V) -> Leq(U,V)*.
7[0:Inp] || Leq(U,V)* Time(U) Time(V) -> Ordered(U,V).
8[0:Inp] || Leq(U,V)* Time(V) Time(U) -> Ordered(V,U).
9[0:Inp] || Leq(U,V)* Time(U) Time(V) -> Lt(U,V) equal(U,V).
10[0:Inp] || Ordered(U,V) Time(U) Time(V) -> Leq(U,V)* Leq(V,U)*.
11[0:Inp] || CContained(U,V,Singleton(W))* RigidObject(W) Lt(U,X)* -> CContained(X,V,Singleton(W))*.
12[0:Inp] || CContained(U,V,Singleton(W))* RigidObject(W) Lt(X,U)* -> CContained(X,V,Singleton(W))*.
 This is a first-order Non-Horn problem containing equality.
 This is a problem that contains sort information.
 All equations are many sorted.
 The conjecture is ground.
 The following monadic predicates have finite extensions: RigidObject.
 Axiom clauses: 8 Conjecture clauses: 4
 Inferences: IEmS=1 ISoR=1 IEqR=1 IEqF=1 ISpR=1 ISpL=1 IORe=1 IOFc=1 
 Reductions: RFRew=1 RBRew=1 RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSST=1 RSSi=1 RFSub=1 RBSub=1 RAED=1 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: Slice > Place > RUnion > HPlace > Singleton > CContained > Leq > Lt > Ordered > Time > RigidObject > Contained > Region > History > Object > ObjectSet > Leq3 > P > Cavity > OSPlace > ClosedContainer > RigidHistory > O > EC > DR > Outside > skc7 > skc6 > skc5 > skc4 > skc3 > skc2 > skc1 > skc0 > Tb2 > Ta2 > Ob2b > Ob2a > Os2
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
1[0:Inp] ||  -> RigidObject(skc6)*.
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
24[0:Res:3.0,23.0] || Lt(skc5,skc4)* -> .
25[0:Res:3.0,22.0] || Lt(skc4,skc5)* -> .
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
20[0:MRR:16.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
21[0:MRR:17.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
23[0:MRR:19.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
22[0:MRR:18.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
15[0:Res:2.0,10.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4)* Leq(skc4,skc5).
8[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
7[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
5[0:Inp] Time(U) Time(V) || Lt(V,U) -> Leq(V,U)*.
6[0:Inp] Time(U) Time(V) || equal(V,U) -> Leq(V,U)*.
13[0:Res:1.0,11.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))* -> CContained(V,W,Singleton(skc6))*.
14[0:Res:1.0,12.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))* -> CContained(U,W,Singleton(skc6))*.
10[0:Inp] Time(U) Time(V) || Ordered(V,U) -> Leq(U,V)* Leq(V,U)*.
9[0:Inp] Time(U) Time(V) || Leq(V,U)* -> equal(V,U) Lt(V,U).
12[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))* -> CContained(V,X,Singleton(U))*.
11[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))* -> CContained(W,X,Singleton(U))*.
	Given clause: 1[0:Inp] ||  -> RigidObject(skc6)*.
	Given clause: 2[0:Inp] ||  -> Ordered(skc4,skc5)*.
	Given clause: 24[0:Res:3.0,23.0] || Lt(skc5,skc4)* -> .
	Given clause: 25[0:Res:3.0,22.0] || Lt(skc4,skc5)* -> .
	Given clause: 3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
	Given clause: 4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
	Given clause: 20[0:MRR:16.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
	Given clause: 21[0:MRR:17.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
	Given clause: 23[0:MRR:19.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
	Given clause: 8[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
	Given clause: 36[0:Res:21.1,23.1] || Lt(U,skc4)*+ Lt(skc5,U)* -> .
	Given clause: 37[0:Res:20.1,23.1] || Lt(skc4,U) Lt(skc5,U)* -> .
	Given clause: 22[0:MRR:18.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
	Given clause: 39[0:Res:21.1,22.1] || Lt(U,skc4) Lt(U,skc5)* -> .
	Given clause: 7[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
	Given clause: 40[0:Res:20.1,22.1] || Lt(skc4,U)*+ Lt(U,skc5)* -> .
	Given clause: 15[0:Res:2.0,10.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4)* Leq(skc4,skc5).
	Given clause: 5[0:Inp] Time(U) Time(V) || Lt(V,U) -> Leq(V,U)*.
	Given clause: 6[0:Inp] Time(U) Time(V) || equal(V,U) -> Leq(V,U)*.
	Given clause: 10[0:Inp] Time(U) Time(V) || Ordered(V,U)+ -> Leq(U,V)* Leq(V,U)*.
	Given clause: 13[0:Res:1.0,11.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))*+ -> CContained(V,W,Singleton(skc6))*.
	Given clause: 51[0:Res:21.1,13.1] || Lt(U,skc4)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 52[0:Res:20.1,13.1] || Lt(skc4,U)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 14[0:Res:1.0,12.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))*+ -> CContained(U,W,Singleton(skc6))*.
	Given clause: 9[0:Inp] Time(U) Time(V) || Leq(V,U)* -> equal(V,U) Lt(V,U).
	Given clause: 54[0:Res:21.1,14.1] || Lt(U,skc4)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 55[0:Res:20.1,14.1] || Lt(skc4,U)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
	Given clause: 12[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))*+ -> CContained(V,X,Singleton(U))*.
	Given clause: 11[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))*+ -> CContained(W,X,Singleton(U))*.
SPASS V 3.5 
SPASS beiseite: Completion found.
Problem: inference2e.dfg 
SPASS derived 42 clauses, backtracked 0 clauses, performed 0 splits and kept 29 clauses.
SPASS allocated 55365 KBytes.
SPASS spent	0:00:00.05 on the problem.
		0:00:00.02 for the input.
		0:00:00.01 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


 The saturated set of worked-off clauses is :
11[0:Inp] RigidObject(U) || Lt(V,W)* CContained(V,X,Singleton(U))*+ -> CContained(W,X,Singleton(U))*.
12[0:Inp] RigidObject(U) || Lt(V,W)* CContained(W,X,Singleton(U))*+ -> CContained(V,X,Singleton(U))*.
55[0:Res:20.1,14.1] || Lt(skc4,U)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
54[0:Res:21.1,14.1] || Lt(U,skc4)*+ Lt(V,U)* -> CContained(V,skc7,Singleton(skc6))*.
9[0:Inp] Time(U) Time(V) || Leq(V,U)* -> equal(V,U) Lt(V,U).
14[0:Res:1.0,12.0] || Lt(U,V)* CContained(V,W,Singleton(skc6))*+ -> CContained(U,W,Singleton(skc6))*.
52[0:Res:20.1,13.1] || Lt(skc4,U)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
51[0:Res:21.1,13.1] || Lt(U,skc4)*+ Lt(U,V)* -> CContained(V,skc7,Singleton(skc6))*.
13[0:Res:1.0,11.0] || Lt(U,V)* CContained(U,W,Singleton(skc6))*+ -> CContained(V,W,Singleton(skc6))*.
10[0:Inp] Time(U) Time(V) || Ordered(V,U)+ -> Leq(U,V)* Leq(V,U)*.
6[0:Inp] Time(U) Time(V) || equal(V,U) -> Leq(V,U)*.
5[0:Inp] Time(U) Time(V) || Lt(V,U) -> Leq(V,U)*.
15[0:Res:2.0,10.2] Time(skc5) Time(skc4) ||  -> Leq(skc5,skc4)* Leq(skc4,skc5).
40[0:Res:20.1,22.1] || Lt(skc4,U)*+ Lt(U,skc5)* -> .
7[0:Inp] Time(U) Time(V) || Leq(V,U)* -> Ordered(V,U).
39[0:Res:21.1,22.1] || Lt(U,skc4) Lt(U,skc5)* -> .
22[0:MRR:18.0,1.0] || Lt(U,skc5) CContained(U,skc7,Singleton(skc6))* -> .
37[0:Res:20.1,23.1] || Lt(skc4,U) Lt(skc5,U)* -> .
36[0:Res:21.1,23.1] || Lt(U,skc4)*+ Lt(skc5,U)* -> .
8[0:Inp] Time(U) Time(V) || Leq(U,V)* -> Ordered(V,U).
23[0:MRR:19.0,1.0] || Lt(skc5,U) CContained(U,skc7,Singleton(skc6))* -> .
21[0:MRR:17.0,1.0] || Lt(U,skc4) -> CContained(U,skc7,Singleton(skc6))*.
20[0:MRR:16.0,1.0] || Lt(skc4,U) -> CContained(U,skc7,Singleton(skc6))*.
4[0:Inp] || CContained(skc5,skc7,Singleton(skc6))* -> .
3[0:Inp] ||  -> CContained(skc4,skc7,Singleton(skc6))*.
25[0:Res:3.0,22.0] || Lt(skc4,skc5)* -> .
24[0:Res:3.0,23.0] || Lt(skc5,skc4)* -> .
2[0:Inp] ||  -> Ordered(skc4,skc5)*.
1[0:Inp] ||  -> RigidObject(skc6)*.
--------------------------SPASS-STOP------------------------------
