
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> EmptyHanded(skc8)*.
2[0:Inp] ||  -> AllStable(skc8)*.
3[0:Inp] ||  -> Region(skc5)*.
4[0:Inp] ||  -> Region(R)*.
5[0:Inp] ||  -> EmptyHanded(Ta)*.
6[0:Inp] ||  -> AllStable(Ta)*.
7[0:Inp] ||  -> Reachable(skc8,skc6)*.
8[0:Inp] ||  -> Reachable(Ta,Rd)*.
9[0:Inp] || Reachable(skc7,skc6)* -> .
10[0:Inp] ||  -> Occurs(skc8,skc7,TravelTo(skc5))*.
11[0:Inp] || SmallObject(U) -> Object(U)*.
12[0:Inp] || IntConn(U)* -> Region(U).
13[0:Inp] || AllStable(U) -> Time(U)*.
14[0:Inp] || EmptyHanded(U) -> Time(U)*.
15[0:Inp] ||  -> Region(U)* Reachable(V,W)*.
16[0:Inp] ||  -> Occurs(Ta,Tb,TravelTo(R))*.
17[0:Inp] || Feasible(U,V)* -> Time(U).
18[0:Inp] || Feasible(U,V)* -> Action(V).
19[0:Inp] || Element(U,V)* -> Object(U).
20[0:Inp] || Element(U,V)* -> ObjectSet(V).
21[0:Inp] || SafelyMovable(U,V)* -> Time(U).
22[0:Inp] || SafelyMovable(U,V)* -> Object(V).
23[0:Inp] || FullyOutside(U,V)* -> Region(U).
24[0:Inp] || FullyOutside(U,V)* -> Region(V).
25[0:Inp] || Reachable(U,V)* -> Time(U).
26[0:Inp] || Reachable(U,V)* -> Region(V).
27[0:Inp] || P(U,V)* -> Region(U).
28[0:Inp] || P(U,V)* -> Region(V).
29[0:Inp] || SkP0(U,V)* -> Region(V).
30[0:Inp] || SkP0(U,V)* -> Region(U).
31[0:Inp] || SmallSet(U,V)* -> ObjectSet(U).
32[0:Inp] || SmallSet(U,V)* -> Region(V).
33[0:Inp] || NoPartialContents(U,V)* -> Time(U).
34[0:Inp] || NoPartialContents(U,V)* -> Object(V).
35[0:Inp] || CanGrasp(U,V)* -> Time(U).
36[0:Inp] || CanGrasp(U,V)* -> Object(V).
37[0:Inp] || Graspable(U,V)* -> Time(U).
38[0:Inp] || Graspable(U,V)* -> Object(V).
39[0:Inp] || Occurs(U,V,W)* -> Time(U).
40[0:Inp] || Occurs(U,V,W)* -> Time(V).
41[0:Inp] || Occurs(U,V,W)* -> Action(W).
42[0:Inp] || UprightContainer(U,V,W)* -> Time(U).
43[0:Inp] || UprightContainer(U,V,W)* -> Object(V).
44[0:Inp] || UprightContainer(U,V,W)* -> Region(W).
45[0:Inp] || UContained(U,V,W)* -> Time(U).
46[0:Inp] || UContained(U,V,W)* -> Object(V).
47[0:Inp] || UContained(U,V,W)* -> Object(W).
48[0:Inp] || BoxedIn(U,V,W)* -> Time(U).
49[0:Inp] || BoxedIn(U,V,W)* -> Object(V).
50[0:Inp] || BoxedIn(U,V,W)* -> Object(W).
51[0:Inp] || FullyOutside(U,V) -> SkP0(V,U)*.
52[0:Inp] || UprightContainerShape(U,V) -> SkP0(V,U)*.
53[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
54[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
55[0:Inp] || Lt(U,V)* Lt(V,W)* -> Lt(U,W)*.
56[0:Inp] || Leq(U,V) Leq(W,U) -> Leq3(W,U,V)*.
57[0:Inp] || Lt(U,V) Time(U) Time(V) -> Leq(U,V)*.
58[0:Inp] || equal(U,V) Time(U) Time(V) -> Leq(U,V)*.
59[0:Inp] || Reachable(U,V) Region(skc9) -> IntConn(RUnion(skf1(U,V),V))*.
60[0:Inp] || Reachable(U,V)* Region(skc9) -> Feasible(U,TravelTo(skf1(U,W)))*.
61[0:Inp] || IntConn(RUnion(U,V))* Feasible(W,TravelTo(U))* -> Reachable(W,V)*.
62[0:Inp] || Leq(U,V)* Time(U) Time(V) -> Lt(U,V) equal(U,V).
63[0:Inp] || Occurs(U,V,TravelTo(W))* EmptyHanded(U) AllStable(U) Feasible(U,TravelTo(X))* Region(W) -> Feasible(V,TravelTo(X))*.
 This is a first-order Non-Horn problem containing equality.
 This is a problem that contains sort information.
 All equations are many sorted.
 The conjecture is ground.
 The following monadic predicates have finite extensions: AllStable, EmptyHanded.
 Axiom clauses: 57 Conjecture clauses: 6
 Inferences: IEmS=1 ISoR=1 IEqR=1 IEqF=1 ISpR=1 ISpL=1 IORe=1 IOFc=1 
 Reductions: RFRew=1 RBRew=1 RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSST=1 RSSi=1 RFSub=1 RBSub=1 RAED=1 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: skf1 > skf0 > RUnion > MovingGroup > Contents > UContents > Union > Place > TravelTo > Leq3 > Leq > Lt > Time > Object > Action > Feasible > IntConn > Reachable > Region > UprightContainer > SkP0 > FullyOutside > ObjectSet > SmallSet > AllStable > EmptyHanded > Graspable > SafelyMovable > SmallObject > BoxedIn > NoPartialContents > Occurs > CanGrasp > UprightContainerShape > UContained > P > Element > skc11 > skc10 > skc9 > skc8 > skc7 > skc6 > skc5 > skc4 > skc3 > skc2 > skc1 > skc0 > Rd > R > Tb > Ta > Ra1 > Tm1 > Agent > Ox4 > Rc4 > Ob4 > Ta4
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
6[0:Inp] ||  -> AllStable(Ta)*.
5[0:Inp] ||  -> EmptyHanded(Ta)*.
2[0:Inp] ||  -> AllStable(skc8)*.
1[0:Inp] ||  -> EmptyHanded(skc8)*.
64[0:MRR:26.0,15.1] ||  -> Region(U)*.
69[0:Res:2.0,13.0] ||  -> Time(skc8)*.
78[0:Res:10.0,40.0] ||  -> Time(skc7)*.
8[0:Inp] ||  -> Reachable(Ta,Rd)*.
7[0:Inp] ||  -> Reachable(skc8,skc6)*.
79[0:Res:10.0,41.0] ||  -> Action(TravelTo(skc5))*.
9[0:Inp] || Reachable(skc7,skc6)* -> .
16[0:Inp] ||  -> Occurs(Ta,Tb,TravelTo(R))*.
10[0:Inp] ||  -> Occurs(skc8,skc7,TravelTo(skc5))*.
11[0:Inp] SmallObject(U) ||  -> Object(U)*.
14[0:Inp] EmptyHanded(U) ||  -> Time(U)*.
13[0:Inp] AllStable(U) ||  -> Time(U)*.
31[0:Inp] || SmallSet(U,V)* -> ObjectSet(U).
20[0:Inp] || Element(U,V)* -> ObjectSet(V).
18[0:Inp] || Feasible(U,V)* -> Action(V).
38[0:Inp] || Graspable(U,V)* -> Object(V).
36[0:Inp] || CanGrasp(U,V)* -> Object(V).
34[0:Inp] || NoPartialContents(U,V)* -> Object(V).
22[0:Inp] || SafelyMovable(U,V)* -> Object(V).
19[0:Inp] || Element(U,V)* -> Object(U).
37[0:Inp] || Graspable(U,V)* -> Time(U).
35[0:Inp] || CanGrasp(U,V)* -> Time(U).
33[0:Inp] || NoPartialContents(U,V)* -> Time(U).
21[0:Inp] || SafelyMovable(U,V)* -> Time(U).
25[0:Inp] || Reachable(U,V)* -> Time(U).
17[0:Inp] || Feasible(U,V)* -> Time(U).
72[0:Res:7.0,66.0] ||  -> IntConn(RUnion(skf1(skc8,skc6),skc6))*.
73[0:Res:7.0,65.0] ||  -> Feasible(skc8,TravelTo(skf1(skc8,U)))*.
52[0:Inp] || UprightContainerShape(U,V) -> SkP0(V,U)*.
51[0:Inp] || FullyOutside(U,V) -> SkP0(V,U)*.
41[0:Inp] || Occurs(U,V,W)* -> Action(W).
43[0:Inp] || UprightContainer(U,V,W)* -> Object(V).
50[0:Inp] || BoxedIn(U,V,W)* -> Object(W).
49[0:Inp] || BoxedIn(U,V,W)* -> Object(V).
47[0:Inp] || UContained(U,V,W)* -> Object(W).
46[0:Inp] || UContained(U,V,W)* -> Object(V).
42[0:Inp] || UprightContainer(U,V,W)* -> Time(U).
48[0:Inp] || BoxedIn(U,V,W)* -> Time(U).
45[0:Inp] || UContained(U,V,W)* -> Time(U).
40[0:Inp] || Occurs(U,V,W)* -> Time(V).
39[0:Inp] || Occurs(U,V,W)* -> Time(U).
54[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
53[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
80[0:MRR:76.0,76.1,1.0,2.0] || Feasible(skc8,TravelTo(U))* -> Feasible(skc7,TravelTo(U)).
66[0:MRR:59.1,64.0] || Reachable(U,V) -> IntConn(RUnion(skf1(U,V),V))*.
65[0:MRR:60.1,64.0] || Reachable(U,V)* -> Feasible(U,TravelTo(skf1(U,W)))*.
75[0:Res:61.2,9.0] || IntConn(RUnion(U,skc6)) Feasible(skc7,TravelTo(U))* -> .
55[0:Inp] || Lt(U,V)* Lt(W,U)* -> Lt(W,V)*.
56[0:Inp] || Leq(U,V) Leq(V,W) -> Leq3(U,V,W)*.
57[0:Inp] Time(U) Time(V) || Lt(V,U) -> Leq(V,U)*.
58[0:Inp] Time(U) Time(V) || equal(V,U) -> Leq(V,U)*.
61[0:Inp] || IntConn(RUnion(U,V))* Feasible(W,TravelTo(U))* -> Reachable(W,V)*.
81[0:MRR:68.0,1.0] || Feasible(skc8,TravelTo(U))* Occurs(skc8,V,TravelTo(W))* -> Feasible(V,TravelTo(U))*.
62[0:Inp] Time(U) Time(V) || Leq(V,U)* -> equal(V,U) Lt(V,U).
67[0:MRR:63.2,64.0] AllStable(U) EmptyHanded(U) || Feasible(U,TravelTo(V))* Occurs(U,W,TravelTo(X))* -> Feasible(W,TravelTo(V))*.
	Given clause: 6[0:Inp] ||  -> AllStable(Ta)*.
	Given clause: 5[0:Inp] ||  -> EmptyHanded(Ta)*.
	Given clause: 2[0:Inp] ||  -> AllStable(skc8)*.
	Given clause: 1[0:Inp] ||  -> EmptyHanded(skc8)*.
	Given clause: 64[0:MRR:26.0,15.1] ||  -> Region(U)*.
	Given clause: 69[0:Res:2.0,13.0] ||  -> Time(skc8)*.
	Given clause: 78[0:Res:10.0,40.0] ||  -> Time(skc7)*.
	Given clause: 8[0:Inp] ||  -> Reachable(Ta,Rd)*.
	Given clause: 7[0:Inp] ||  -> Reachable(skc8,skc6)*.
	Given clause: 9[0:Inp] || Reachable(skc7,skc6)* -> .
	Given clause: 79[0:Res:10.0,41.0] ||  -> Action(TravelTo(skc5))*.
	Given clause: 16[0:Inp] ||  -> Occurs(Ta,Tb,TravelTo(R))*.
	Given clause: 10[0:Inp] ||  -> Occurs(skc8,skc7,TravelTo(skc5))*.
	Given clause: 11[0:Inp] SmallObject(U) ||  -> Object(U)*.
	Given clause: 14[0:Inp] EmptyHanded(U) ||  -> Time(U)*.
	Given clause: 13[0:Inp] AllStable(U) ||  -> Time(U)*.
	Given clause: 72[0:Res:7.0,66.0] ||  -> IntConn(RUnion(skf1(skc8,skc6),skc6))*.
	Given clause: 73[0:Res:7.0,65.0] ||  -> Feasible(skc8,TravelTo(skf1(skc8,U)))*.
	Given clause: 31[0:Inp] || SmallSet(U,V)* -> ObjectSet(U).
	Given clause: 20[0:Inp] || Element(U,V)* -> ObjectSet(V).
	Given clause: 18[0:Inp] || Feasible(U,V)* -> Action(V).
	Given clause: 121[0:Res:73.0,18.0] ||  -> Action(TravelTo(skf1(skc8,U)))*.
	Given clause: 38[0:Inp] || Graspable(U,V)* -> Object(V).
	Given clause: 36[0:Inp] || CanGrasp(U,V)* -> Object(V).
	Given clause: 34[0:Inp] || NoPartialContents(U,V)* -> Object(V).
	Given clause: 22[0:Inp] || SafelyMovable(U,V)* -> Object(V).
	Given clause: 19[0:Inp] || Element(U,V)* -> Object(U).
	Given clause: 37[0:Inp] || Graspable(U,V)* -> Time(U).
	Given clause: 35[0:Inp] || CanGrasp(U,V)* -> Time(U).
	Given clause: 33[0:Inp] || NoPartialContents(U,V)* -> Time(U).
	Given clause: 21[0:Inp] || SafelyMovable(U,V)* -> Time(U).
	Given clause: 25[0:Inp] || Reachable(U,V)* -> Time(U).
	Given clause: 122[0:Res:8.0,25.0] ||  -> Time(Ta)*.
	Given clause: 17[0:Inp] || Feasible(U,V)* -> Time(U).
	Given clause: 52[0:Inp] || UprightContainerShape(U,V) -> SkP0(V,U)*.
	Given clause: 51[0:Inp] || FullyOutside(U,V) -> SkP0(V,U)*.
	Given clause: 41[0:Inp] || Occurs(U,V,W)* -> Action(W).
	Given clause: 125[0:Res:16.0,41.0] ||  -> Action(TravelTo(R))*.
	Given clause: 43[0:Inp] || UprightContainer(U,V,W)* -> Object(V).
	Given clause: 50[0:Inp] || BoxedIn(U,V,W)* -> Object(W).
	Given clause: 49[0:Inp] || BoxedIn(U,V,W)* -> Object(V).
	Given clause: 47[0:Inp] || UContained(U,V,W)* -> Object(W).
	Given clause: 46[0:Inp] || UContained(U,V,W)* -> Object(V).
	Given clause: 42[0:Inp] || UprightContainer(U,V,W)* -> Time(U).
	Given clause: 48[0:Inp] || BoxedIn(U,V,W)* -> Time(U).
	Given clause: 45[0:Inp] || UContained(U,V,W)* -> Time(U).
	Given clause: 40[0:Inp] || Occurs(U,V,W)* -> Time(V).
	Given clause: 127[0:Res:16.0,40.0] ||  -> Time(Tb)*.
	Given clause: 39[0:Inp] || Occurs(U,V,W)* -> Time(U).
	Given clause: 54[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
	Given clause: 53[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
	Given clause: 80[0:MRR:76.0,76.1,1.0,2.0] || Feasible(skc8,TravelTo(U))* -> Feasible(skc7,TravelTo(U)).
	Given clause: 131[0:Res:73.0,80.0] ||  -> Feasible(skc7,TravelTo(skf1(skc8,U)))*.
	Given clause: 75[0:Res:61.2,9.0] || IntConn(RUnion(U,skc6)) Feasible(skc7,TravelTo(U))* -> .
SPASS V 3.5 
SPASS beiseite: Proof found.
Problem: g.dfg 
SPASS derived 27 clauses, backtracked 0 clauses, performed 0 splits and kept 74 clauses.
SPASS allocated 55636 KBytes.
SPASS spent	0:00:00.06 on the problem.
		0:00:00.02 for the input.
		0:00:00.02 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


Here is a proof with depth 3, length 23 :
1[0:Inp] ||  -> EmptyHanded(skc8)*.
2[0:Inp] ||  -> AllStable(skc8)*.
7[0:Inp] ||  -> Reachable(skc8,skc6)*.
9[0:Inp] || Reachable(skc7,skc6)* -> .
10[0:Inp] ||  -> Occurs(skc8,skc7,TravelTo(skc5))*.
15[0:Inp] ||  -> Region(U)* Reachable(V,W)*.
26[0:Inp] || Reachable(U,V)* -> Region(V).
59[0:Inp] || Reachable(U,V) Region(skc9) -> IntConn(RUnion(skf1(U,V),V))*.
60[0:Inp] || Reachable(U,V)* Region(skc9) -> Feasible(U,TravelTo(skf1(U,W)))*.
61[0:Inp] || IntConn(RUnion(U,V))* Feasible(W,TravelTo(U))* -> Reachable(W,V)*.
63[0:Inp] EmptyHanded(U) AllStable(U) Region(V) || Feasible(U,TravelTo(W))* Occurs(U,X,TravelTo(V))* -> Feasible(X,TravelTo(W))*.
64[0:MRR:26.0,15.1] ||  -> Region(U)*.
65[0:MRR:60.1,64.0] || Reachable(U,V)* -> Feasible(U,TravelTo(skf1(U,W)))*.
66[0:MRR:59.1,64.0] || Reachable(U,V) -> IntConn(RUnion(skf1(U,V),V))*.
67[0:MRR:63.2,64.0] AllStable(U) EmptyHanded(U) || Feasible(U,TravelTo(V))* Occurs(U,W,TravelTo(X))* -> Feasible(W,TravelTo(V))*.
72[0:Res:7.0,66.0] ||  -> IntConn(RUnion(skf1(skc8,skc6),skc6))*.
73[0:Res:7.0,65.0] ||  -> Feasible(skc8,TravelTo(skf1(skc8,U)))*.
75[0:Res:61.2,9.0] || IntConn(RUnion(U,skc6)) Feasible(skc7,TravelTo(U))* -> .
76[0:Res:10.0,67.3] EmptyHanded(skc8) AllStable(skc8) || Feasible(skc8,TravelTo(U))* -> Feasible(skc7,TravelTo(U)).
80[0:MRR:76.0,76.1,1.0,2.0] || Feasible(skc8,TravelTo(U))* -> Feasible(skc7,TravelTo(U)).
131[0:Res:73.0,80.0] ||  -> Feasible(skc7,TravelTo(skf1(skc8,U)))*.
134[0:Res:131.0,75.1] || IntConn(RUnion(skf1(skc8,U),skc6))* -> .
135[0:UnC:134.0,72.0] ||  -> .
Formulae used in the proof : conjecture0 axiom22 axiom8 axiom23

--------------------------SPASS-STOP------------------------------
