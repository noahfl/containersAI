
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> EmptyHanded(skc11)*.
2[0:Inp] ||  -> AllStable(skc11)*.
3[0:Inp] ||  -> Region(skc8)*.
4[0:Inp] ||  -> Region(U)*.
5[0:Inp] ||  -> EmptyHanded(U)*.
6[0:Inp] ||  -> AllStable(U)*.
7[0:Inp] ||  -> Object(U)*.
8[0:Inp] ||  -> EmptyHanded(U)*.
9[0:Inp] ||  -> AllStable(U)*.
10[0:Inp] ||  -> EmptyHanded(U)*.
11[0:Inp] ||  -> AllStable(U)*.
12[0:Inp] ||  -> NoObstacles(U,V)*.
13[0:Inp] ||  -> NoObstacles(U,V)*.
14[0:Inp] ||  -> Feasible(skc11,TravelTo(skc9))*.
15[0:Inp] ||  -> Object(skf7(U,V))*.
16[0:Inp] ||  -> Object(skf9(U,V))*.
17[0:Inp] ||  -> Trajectory(U,V,W)*.
18[0:Inp] ||  -> Occurs(skc11,skc10,TravelTo(skc8))*.
19[0:Inp] || Feasible(skc10,TravelTo(skc9))* -> .
20[0:Inp] || SmallObject(U) -> Object(U)*.
21[0:Inp] || AllStable(U) -> Time(U)*.
22[0:Inp] || EmptyHanded(U)* -> Time(U).
23[0:Inp] ||  -> Occurs(U,V,TravelTo(W))*.
24[0:Inp] || EmptyHanded(U)* -> Time(U).
25[0:Inp] || EmptyHanded(U)* -> Object(V)*.
26[0:Inp] ||  -> Time(U)* Feasible(V,W)*.
27[0:Inp] || Feasible(U,V)* -> Time(U).
28[0:Inp] || Feasible(U,V)* -> Action(V).
29[0:Inp] || Element(U,V)* -> Object(U).
30[0:Inp] || Element(U,V)* -> ObjectSet(V).
31[0:Inp] || SafelyMovable(U,V)* -> Time(U).
32[0:Inp] || SafelyMovable(U,V)* -> Object(V).
33[0:Inp] || FullyOutside(U,V)* -> Region(U).
34[0:Inp] || FullyOutside(U,V)* -> Region(V).
35[0:Inp] || Reachable(U,V)* -> Time(U).
36[0:Inp] || Reachable(U,V)* -> Region(V).
37[0:Inp] || SkP0(U,V)* -> Region(V).
38[0:Inp] || SkP0(U,V)* -> Region(U).
39[0:Inp] || SkP1(U,V)* -> Region(V).
40[0:Inp] || SkP1(U,V)* -> Region(U).
41[0:Inp] || SmallSet(U,V)* -> ObjectSet(U).
42[0:Inp] || SmallSet(U,V)* -> Region(V).
43[0:Inp] || NoPartialContents(U,V)* -> Time(U).
44[0:Inp] || NoPartialContents(U,V)* -> Object(V).
45[0:Inp] || SkP2(U,V)* -> Time(V).
46[0:Inp] || SkP2(U,V)* -> Object(U).
47[0:Inp] || Graspable(U,V)* -> Time(U).
48[0:Inp] || Graspable(U,V)* -> Object(V).
49[0:Inp] || NoObstacles(U,V)* -> Time(U).
50[0:Inp] || NoObstacles(U,V)* -> Region(V).
51[0:Inp] || NoObstacles(U,V)* -> Time(U).
52[0:Inp] ||  -> Lt(U,skf13(V,W,U))*.
53[0:Inp] || Occurs(U,V,W)* -> Time(U).
54[0:Inp] || Occurs(U,V,W)* -> Time(V).
55[0:Inp] || Occurs(U,V,W)* -> Action(W).
56[0:Inp] || UprightContainer(U,V,W)* -> Time(U).
57[0:Inp] || UprightContainer(U,V,W)* -> Object(V).
58[0:Inp] || UprightContainer(U,V,W)* -> Region(W).
59[0:Inp] || UContained(U,V,W)* -> Time(U).
60[0:Inp] || UContained(U,V,W)* -> Object(V).
61[0:Inp] || UContained(U,V,W)* -> Object(W).
62[0:Inp] || BoxedIn(U,V,W)* -> Time(U).
63[0:Inp] || BoxedIn(U,V,W)* -> Object(V).
64[0:Inp] || BoxedIn(U,V,W)* -> Object(W).
65[0:Inp] || P(U,V) -> SkP0(V,U)*.
66[0:Inp] || DR(U,V) -> SkP0(V,U)*.
67[0:Inp] || FullyOutside(U,V) -> SkP1(V,U)*.
68[0:Inp] || UprightContainerShape(U,V) -> SkP1(V,U)*.
69[0:Inp] || CanGrasp(U,V) -> SkP2(V,U)*.
70[0:Inp] || Grasp(U,V) -> SkP2(V,U)*.
71[0:Inp] || Released(U,V,W)* -> Time(U).
72[0:Inp] || Released(U,V,W)* -> Time(V).
73[0:Inp] || Released(U,V,W)* -> Object(W).
74[0:Inp] || Trajectory(U,V,W)* -> Time(U).
75[0:Inp] || Trajectory(U,V,W)* -> Time(V).
76[0:Inp] || Trajectory(U,V,W)* -> Time(W).
77[0:Inp] || Grasp(U,V)* EmptyHanded(U) -> .
78[0:Inp] || Released(U,V,W)* -> Object(W).
79[0:Inp] || StaysIn(U,V,W,X)* -> Time(U).
80[0:Inp] || StaysIn(U,V,W,X)* -> Time(V).
81[0:Inp] || StaysIn(U,V,W,X)* -> Object(W).
82[0:Inp] || StaysIn(U,V,W,X)* -> Region(X).
83[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
84[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
85[0:Inp] ||  -> Occurs(U,skf11(V,W,U),TravelTo(W))*.
86[0:Inp] || Occurs(U,V,W)* -> Feasible(U,W).
87[0:Inp] || Released(U,V,W)* -> Lt(U,V).
88[0:Inp] || Trajectory(U,V,W)* -> Trajectory(V,U,W)*.
89[0:Inp] ||  -> Trajectory(Place(U,Agent),V,skf10(W,V,U))*.
90[0:Inp] ||  -> equal(Place(U,V),Place(W,V))* equal(V,Agent).
91[0:Inp] || Lt(U,V)* Lt(V,W)* -> Lt(U,W)*.
92[0:Inp] || Occurs(U,V,TravelTo(W))* -> equal(W,Place(V,Agent)).
93[0:Inp] || Leq(U,V) Leq(W,U) -> Leq3(W,U,V)*.
94[0:Inp] || Time(U) Object(skc12) -> Grasp(U,skf8(U))* EmptyHanded(U).
95[0:Inp] || equal(skf9(U,V),Agent)** Time(V) -> NoObstacles(V,U).
96[0:Inp] || Lt(U,V) Time(U) Time(V) -> Leq(U,V)*.
97[0:Inp] || equal(U,V) Time(U) Time(V) -> Leq(U,V)*.
98[0:Inp] || Object(U) Occurs(V,W,TravelTo(X))* -> Released(V,W,U)*.
99[0:Inp] || Feasible(U,V) Time(skc19) -> Occurs(U,skf12(V,U),V)*.
100[0:Inp] || DR(Place(U,skf9(V,U)),V)* Time(U) -> NoObstacles(U,V).
101[0:Inp] || Object(U) NoObstacles(V,W) -> equal(U,Agent) DR(Place(V,U),W)*.
102[0:Inp] || Occurs(U,V,TravelTo(W)) Region(skc13) -> NoObstacles(U,skf10(V,W,U))*.
103[0:Inp] || Leq(U,V)* Time(U) Time(V) -> Lt(U,V) equal(U,V).
104[0:Inp] || Occurs(U,V,TravelTo(W)) Region(skc13) -> StaysIn(U,V,Agent,skf10(V,W,U))*.
105[0:Inp] || Lt(U,V)* Leq(V,W)* Grasp(V,X)* Released(U,W,X)* -> .
106[0:Inp] || Lt(U,V) Object(W) -> Leq(skf13(W,V,U),V)* Released(U,V,W).
107[0:Inp] || Lt(U,V) Object(W) -> Grasp(skf13(W,V,U),W)* Released(U,V,W).
108[0:Inp] || Released(U,V,skf7(V,U))* equal(W,Place(V,Agent)) -> Occurs(U,V,TravelTo(W))*.
109[0:Inp] || Trajectory(Place(U,Agent),V,W) Time(skc16) -> StaysIn(U,skf11(W,V,U),Agent,W)*.
 This is a first-order Non-Horn problem containing equality.
 This is a problem that contains sort information.
 The conjecture is ground.
 Axiom clauses: 103 Conjecture clauses: 6
 Inferences: IEmS=1 ISoR=1 IEqR=1 IEqF=1 ISpR=1 ISpL=1 IORe=1 IOFc=1 
 Reductions: RFRew=1 RBRew=1 RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSSi=1 RFSub=1 RBSub=1 RAED=1 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: skf13 > skf11 > skf10 > skf6 > skf4 > skf3 > skf12 > skf9 > skf7 > skf5 > skf2 > skf0 > MovingGroup > Contents > UContents > RUnion > Union > Place > skf8 > skf1 > TravelTo > Action > SkP2 > SkP0 > Feasible > DR > Grasp > Released > NoObstacles > StaysIn > Leq3 > Leq > Lt > Occurs > EmptyHanded > Region > Object > Time > UprightContainer > SkP1 > FullyOutside > ObjectSet > SmallSet > AllStable > Graspable > Reachable > SafelyMovable > SmallObject > BoxedIn > NoPartialContents > CanGrasp > UprightContainerShape > UContained > P > Element > Trajectory > skc20 > skc19 > skc18 > skc17 > skc16 > skc15 > skc14 > skc13 > skc12 > skc11 > skc10 > skc9 > skc8 > skc7 > skc6 > skc5 > skc4 > skc3 > skc2 > skc1 > skc0 > Ra1 > Tm1 > Agent > Ox4 > Rc4 > Ob4 > Ta4
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
11[0:Inp] ||  -> AllStable(U)*.
10[0:Inp] ||  -> EmptyHanded(U)*.
7[0:Inp] ||  -> Object(U)*.
4[0:Inp] ||  -> Region(U)*.
110[0:MRR:24.0,10.0] ||  -> Time(U)*.
13[0:Inp] ||  -> NoObstacles(U,V)*.
115[0:MRR:87.0,114.0] ||  -> Lt(U,V)*.
117[0:MRR:96.0,96.1,96.2,110.0,110.0,115.0] ||  -> Leq(U,V)*.
123[0:Res:14.0,28.0] ||  -> Action(TravelTo(skc9))*.
14[0:Inp] ||  -> Feasible(skc11,TravelTo(skc9))*.
111[0:MRR:77.0,10.0] || Grasp(U,V)* -> .
17[0:Inp] ||  -> Trajectory(U,V,W)*.
114[0:MRR:98.0,98.1,7.0,23.0] ||  -> Released(U,V,W)*.
118[0:MRR:93.1,93.0,117.0] ||  -> Leq3(U,V,W)*.
19[0:Inp] || Feasible(skc10,TravelTo(skc9))* -> .
112[0:MRR:92.0,23.0] ||  -> equal(U,Place(V,Agent))*.
23[0:Inp] ||  -> Occurs(U,V,TravelTo(W))*.
41[0:Inp] || SmallSet(U,V)* -> ObjectSet(U).
30[0:Inp] || Element(U,V)* -> ObjectSet(V).
28[0:Inp] || Feasible(U,V)* -> Action(V).
69[0:Inp] || CanGrasp(U,V) -> SkP2(V,U)*.
68[0:Inp] || UprightContainerShape(U,V) -> SkP1(V,U)*.
67[0:Inp] || FullyOutside(U,V) -> SkP1(V,U)*.
65[0:Inp] || P(U,V) -> SkP0(V,U)*.
66[0:Inp] || DR(U,V) -> SkP0(V,U)*.
55[0:Inp] || Occurs(U,V,W)* -> Action(W).
121[0:MRR:109.0,109.1,17.0,110.0] ||  -> StaysIn(U,skf11(V,W,U),Agent,V)*.
120[0:MRR:104.0,104.1,23.0,4.0] ||  -> StaysIn(U,V,Agent,skf10(V,W,U))*.
119[0:MRR:101.0,101.1,7.0,13.0] ||  -> equal(U,Agent) DR(Place(V,U),W)*.
86[0:Inp] || Occurs(U,V,W)* -> Feasible(U,W).
113[0:MRR:99.1,110.0] || Feasible(U,V) -> Occurs(U,skf12(V,U),V)*.
90[0:Inp] ||  -> equal(U,Agent) equal(Place(V,U),Place(W,U))*.
SPASS V 3.5 
SPASS beiseite: Proof found.
Problem: f.dfg 
SPASS derived 4 clauses, backtracked 0 clauses, performed 0 splits and kept 41 clauses.
SPASS allocated 52450 KBytes.
SPASS spent	0:00:00.04 on the problem.
		0:00:00.01 for the input.
		0:00:00.01 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


Here is a proof with depth 1, length 5 :
19[0:Inp] || Feasible(skc10,TravelTo(skc9))* -> .
23[0:Inp] ||  -> Occurs(U,V,TravelTo(W))*.
86[0:Inp] || Occurs(U,V,W)* -> Feasible(U,W).
124[0:Res:86.1,19.0] || Occurs(skc10,U,TravelTo(skc9))* -> .
125[0:MRR:124.0,23.0] ||  -> .
Formulae used in the proof : conjecture0 axiom25 axiom34

--------------------------SPASS-STOP------------------------------
