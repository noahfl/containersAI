
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> Fixed(Ob3)*.
2[0:Inp] ||  -> Lt(Ta3,Tb3)*.
3[0:Inp] || equal(Ob3,Os3)** -> .
4[0:Inp] ||  -> P(Place(Ta3,Os3),RInside)*.
5[0:Inp] ||  -> CombinedContainer(Place(Ta3,Ob3),RRed,RInside)*.
6[0:Inp] || CombinedContainer(U,V,W)* -> EC(U,V).
7[0:Inp] || Cavity(U,V) CombinedContainer(V,W,U)* -> .
8[0:Inp] || Cavity(U,V) CombinedContainer(W,V,U)* -> .
9[0:Inp] || CombinedContainer(U,V,W) -> Cavity(W,RUnion(U,V))*.
10[0:Inp] || Constant(Ta3,Tb3,U)* equal(Slice(Ta3,U),RInside) -> .
11[0:Inp] || Region(U) Lt(V,W) -> Constant(V,W,skf1(U,V,W))*.
12[0:Inp] || Region(U) Lt(V,W)* -> equal(Slice(V,skf1(U,V,X)),U)**.
13[0:Inp] || Cavity(U,RUnion(V,W))* EC(V,W) -> Cavity(U,V) Cavity(U,W) CombinedContainer(V,W,U).
14[0:Inp] || Constant(U,V,W) Constant(U,V,X) Cavity(Slice(U,W),Slice(U,X))* -> PersistentCavity(U,V,W,X)*.
 This is a first-order Non-Horn problem containing equality.
 This is a problem that has, if any, a non-trivial domain model.
 This is a problem that contains sort information.
 The following monadic predicates have finite extensions: Fixed.
 Axiom clauses: 13 Conjecture clauses: 1
 Inferences: IEmS=1 ISoR=1 IEqR=1 IEqF=1 ISpR=1 ISpL=1 IORe=1 IOFc=1 
 Reductions: RFRew=1 RBRew=1 RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSSi=1 RFSub=1 RBSub=1 RAED=2 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: skf1 > skf0 > RUnion > Place > Slice > HPlace > Fixed > History > Object > PersistentCavity > EC > Cavity > CombinedContainer > Constant > Region > P > Outside > Lt > NoExitCavity > NoEntranceCavity > Continuous > O > DR > Leq > Leq3 > AlwaysIntConn > IntConn > Motionless > Stable > Time > FeasiblePlace > skc3 > skc2 > skc1 > skc0 > HC > HB > Tb3 > Ta3 > RInside > RGreen > RRed > Ob3 > Os3
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
1[0:Inp] ||  -> Fixed(Ob3)*.
2[0:Inp] ||  -> Lt(Ta3,Tb3)*.
3[0:Inp] || equal(Ob3,Os3)** -> .
4[0:Inp] ||  -> P(Place(Ta3,Os3),RInside)*.
5[0:Inp] ||  -> CombinedContainer(Place(Ta3,Ob3),RRed,RInside)*.
6[0:Inp] || CombinedContainer(U,V,W)* -> EC(U,V).
8[0:Inp] || Cavity(U,V) CombinedContainer(W,V,U)* -> .
7[0:Inp] || Cavity(U,V) CombinedContainer(V,W,U)* -> .
9[0:Inp] || CombinedContainer(U,V,W) -> Cavity(W,RUnion(U,V))*.
10[0:Inp] || equal(Slice(Ta3,U),RInside) Constant(Ta3,Tb3,U)* -> .
11[0:Inp] Region(U) || Lt(V,W) -> Constant(V,W,skf1(U,V,W))*.
12[0:Inp] Region(U) || Lt(V,W)* -> equal(Slice(V,skf1(U,V,X)),U)**.
13[0:Inp] || EC(U,V) Cavity(W,RUnion(U,V))* -> Cavity(W,V) Cavity(W,U) CombinedContainer(U,V,W).
14[0:Inp] || Cavity(Slice(U,V),Slice(U,W))* Constant(U,X,W) Constant(U,X,V) -> PersistentCavity(U,X,V,W)*.
	Given clause: 1[0:Inp] ||  -> Fixed(Ob3)*.
	Given clause: 2[0:Inp] ||  -> Lt(Ta3,Tb3)*.
	Given clause: 3[0:Inp] || equal(Ob3,Os3)** -> .
	Given clause: 4[0:Inp] ||  -> P(Place(Ta3,Os3),RInside)*.
	Given clause: 5[0:Inp] ||  -> CombinedContainer(Place(Ta3,Ob3),RRed,RInside)*.
	Given clause: 6[0:Inp] || CombinedContainer(U,V,W)* -> EC(U,V).
	Given clause: 15[0:Res:5.0,6.0] ||  -> EC(Place(Ta3,Ob3),RRed)*.
	Given clause: 8[0:Inp] || Cavity(U,V) CombinedContainer(W,V,U)* -> .
	Given clause: 16[0:Res:5.0,8.1] || Cavity(RInside,RRed)* -> .
	Given clause: 7[0:Inp] || Cavity(U,V) CombinedContainer(V,W,U)* -> .
	Given clause: 17[0:Res:5.0,7.1] || Cavity(RInside,Place(Ta3,Ob3))* -> .
	Given clause: 9[0:Inp] || CombinedContainer(U,V,W) -> Cavity(W,RUnion(U,V))*.
	Given clause: 10[0:Inp] || equal(Slice(Ta3,U),RInside) Constant(Ta3,Tb3,U)* -> .
	Given clause: 11[0:Inp] Region(U) || Lt(V,W) -> Constant(V,W,skf1(U,V,W))*.
	Given clause: 12[0:Inp] Region(U) || Lt(V,W)*+ -> equal(Slice(V,skf1(U,V,X)),U)**.
	Given clause: 20[0:MRR:19.1,2.0] Region(U) || equal(U,RInside)* -> .
	Given clause: 21[0:Res:2.0,12.1] Region(U) ||  -> equal(Slice(Ta3,skf1(U,Ta3,V)),U)**.
	Given clause: 13[0:Inp] || EC(U,V) Cavity(W,RUnion(U,V))* -> Cavity(W,V) Cavity(W,U) CombinedContainer(U,V,W).
	Given clause: 14[0:Inp] || Cavity(Slice(U,V),Slice(U,W))*+ Constant(U,X,W) Constant(U,X,V) -> PersistentCavity(U,X,V,W)*.
	Given clause: 25[0:SpL:21.1,14.0] Region(U) || Cavity(U,Slice(Ta3,V)) Constant(Ta3,W,V) Constant(Ta3,W,skf1(U,Ta3,X)) -> PersistentCavity(Ta3,W,skf1(U,Ta3,X),V)*.
	Given clause: 24[0:SpL:21.1,14.0] Region(U) || Cavity(Slice(Ta3,V),U) Constant(Ta3,W,skf1(U,Ta3,X)) Constant(Ta3,W,V) -> PersistentCavity(Ta3,W,V,skf1(U,Ta3,X))*.
SPASS V 3.5 
SPASS beiseite: Completion found.
Problem: inference3_4.dfg 
SPASS derived 9 clauses, backtracked 0 clauses, performed 0 splits and kept 21 clauses.
SPASS allocated 52236 KBytes.
SPASS spent	0:00:00.05 on the problem.
		0:00:00.02 for the input.
		0:00:00.01 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


 The saturated set of worked-off clauses is :
24[0:SpL:21.1,14.0] Region(U) || Cavity(Slice(Ta3,V),U) Constant(Ta3,W,skf1(U,Ta3,X)) Constant(Ta3,W,V) -> PersistentCavity(Ta3,W,V,skf1(U,Ta3,X))*.
25[0:SpL:21.1,14.0] Region(U) || Cavity(U,Slice(Ta3,V)) Constant(Ta3,W,V) Constant(Ta3,W,skf1(U,Ta3,X)) -> PersistentCavity(Ta3,W,skf1(U,Ta3,X),V)*.
14[0:Inp] || Cavity(Slice(U,V),Slice(U,W))*+ Constant(U,X,W) Constant(U,X,V) -> PersistentCavity(U,X,V,W)*.
13[0:Inp] || EC(U,V) Cavity(W,RUnion(U,V))* -> Cavity(W,V) Cavity(W,U) CombinedContainer(U,V,W).
21[0:Res:2.0,12.1] Region(U) ||  -> equal(Slice(Ta3,skf1(U,Ta3,V)),U)**.
20[0:MRR:19.1,2.0] Region(U) || equal(U,RInside)* -> .
12[0:Inp] Region(U) || Lt(V,W)*+ -> equal(Slice(V,skf1(U,V,X)),U)**.
11[0:Inp] Region(U) || Lt(V,W) -> Constant(V,W,skf1(U,V,W))*.
10[0:Inp] || equal(Slice(Ta3,U),RInside) Constant(Ta3,Tb3,U)* -> .
9[0:Inp] || CombinedContainer(U,V,W) -> Cavity(W,RUnion(U,V))*.
17[0:Res:5.0,7.1] || Cavity(RInside,Place(Ta3,Ob3))* -> .
7[0:Inp] || Cavity(U,V) CombinedContainer(V,W,U)* -> .
16[0:Res:5.0,8.1] || Cavity(RInside,RRed)* -> .
8[0:Inp] || Cavity(U,V) CombinedContainer(W,V,U)* -> .
15[0:Res:5.0,6.0] ||  -> EC(Place(Ta3,Ob3),RRed)*.
6[0:Inp] || CombinedContainer(U,V,W)* -> EC(U,V).
5[0:Inp] ||  -> CombinedContainer(Place(Ta3,Ob3),RRed,RInside)*.
4[0:Inp] ||  -> P(Place(Ta3,Os3),RInside)*.
3[0:Inp] || equal(Ob3,Os3)** -> .
2[0:Inp] ||  -> Lt(Ta3,Tb3)*.
1[0:Inp] ||  -> Fixed(Ob3)*.
--------------------------SPASS-STOP------------------------------
