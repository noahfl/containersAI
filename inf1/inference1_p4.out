
--------------------------SPASS-START-----------------------------
Input Problem:
1[0:Inp] ||  -> RigidObject(Ob1)*.
2[0:Inp] ||  -> Lt(Ta1,Tb1)*.
3[0:Inp] || RigidObject(U) -> Object(U)*.
4[0:Inp] || RigidHistory(U) -> History(U)*.
5[0:Inp] ||  -> CContained(Ta1,Ox1,Singleton(Ob1))*.
6[0:Inp] || CContained(Tb1,Ox1,Singleton(Ob1))* -> .
7[0:Inp] || Lt(U,V)* -> Time(U).
8[0:Inp] || Lt(U,V)* -> Time(V).
9[0:Inp] || Leq(U,V)* -> Time(U).
10[0:Inp] || Leq(U,V)* -> Time(V).
11[0:Inp] || Ordered(U,V)* -> Time(U).
12[0:Inp] || Ordered(U,V)* -> Time(V).
13[0:Inp] || SkP0(U,V)* -> Region(V).
14[0:Inp] || SkP0(U,V)* -> Region(U).
15[0:Inp] || SkP1(U,V)* -> Region(V).
16[0:Inp] || SkP1(U,V)* -> Region(U).
17[0:Inp] || Object(U) -> ObjectSet(Singleton(U))*.
18[0:Inp] || Object(U) -> History(HPlace(U))*.
19[0:Inp] ||  -> NoExitCavity(Ta1,Tb1,Hc1,HPlace(Ob1))*.
20[0:Inp] || Leq3(U,V,W)* -> Time(U).
21[0:Inp] || Leq3(U,V,W)* -> Time(V).
22[0:Inp] || Leq3(U,V,W)* -> Time(W).
23[0:Inp] || P(U,V) -> SkP0(V,U)*.
24[0:Inp] || O(U,V) -> SkP0(V,U)*.
25[0:Inp] || EC(U,V) -> SkP0(V,U)*.
26[0:Inp] || DR(U,V) -> SkP0(V,U)*.
27[0:Inp] || Cavity(U,V) -> SkP1(V,U)*.
28[0:Inp] || Outside(U,V) -> SkP1(V,U)*.
29[0:Inp] || OSPlace(U,V,W)* -> Time(U).
30[0:Inp] || OSPlace(U,V,W)* -> ObjectSet(V).
31[0:Inp] || OSPlace(U,V,W)* -> Region(W).
32[0:Inp] || ClosedContainer(U,V,W)* -> Time(U).
33[0:Inp] || ClosedContainer(U,V,W)* -> ObjectSet(V).
34[0:Inp] || ClosedContainer(U,V,W)* -> Region(W).
35[0:Inp] || CContained(U,V,W)* -> Time(U).
36[0:Inp] || CContained(U,V,W)* -> Object(V).
37[0:Inp] || CContained(U,V,W)* -> ObjectSet(W).
38[0:Inp] || SkP2(U,V,W)* -> Time(W).
39[0:Inp] || SkP2(U,V,W)* -> Time(V).
40[0:Inp] || SkP2(U,V,W)* -> History(U).
41[0:Inp] || Constant(U,V,W)* -> Time(U).
42[0:Inp] || Constant(U,V,W)* -> Time(V).
43[0:Inp] || Constant(U,V,W)* -> History(W).
44[0:Inp] || CContained(U,V,W)* -> Object(V).
45[0:Inp] || Lt(U,V) -> Leq(U,V)*.
46[0:Inp] || equal(U,V) -> Leq(U,V)*.
47[0:Inp] || SkP3(U,V,W,X)* -> Time(X).
48[0:Inp] || SkP3(U,V,W,X)* -> Time(W).
49[0:Inp] || SkP3(U,V,W,X)* -> History(V).
50[0:Inp] || SkP3(U,V,W,X)* -> History(U).
51[0:Inp] ||  -> P(Slice(Tb1,HPlace(Ox1)),Slice(Tb1,Hc1))*.
52[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
53[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
54[0:Inp] || Continuous(U,V,W) -> SkP2(W,V,U)*.
55[0:Inp] || WeaklyContinuous(U,V,W) -> SkP2(W,V,U)*.
56[0:Inp] || SkP4(U,V,W,X)* -> Lt(X,W).
57[0:Inp] || Region(U) Region(V) -> Region(RUnion(U,V))*.
58[0:Inp] || Time(U) Object(V) -> Region(Place(U,V))*.
59[0:Inp] || Time(U) History(V) -> Region(Slice(U,V))*.
60[0:Inp] || SkP4(U,V,W,X)* -> WeaklyContinuous(X,W,V).
61[0:Inp] || Leq(U,V)* -> Lt(U,V) equal(U,V).
62[0:Inp] || NoExitCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
63[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
64[0:Inp] || PersistentCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
65[0:Inp] || NoExitCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
66[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
67[0:Inp] || ClosedContainer(U,V,W)* -> Cavity(W,skf2(W,X,Y))*.
68[0:Inp] || ClosedContainer(U,V,W) -> OSPlace(U,V,skf2(W,V,U))*.
69[0:Inp] || CContained(U,V,W) -> ClosedContainer(U,W,skf3(V,U,W))*.
70[0:Inp] || Leq(U,V) Leq(W,U) -> Leq3(W,U,V)*.
71[0:Inp] || OSPlace(U,V,W)* Cavity(X,W)* -> ClosedContainer(U,V,X)*.
72[0:Inp] || CContained(U,V,W)* -> P(Place(U,V),skf3(V,U,X))*.
73[0:Inp] || Time(U) Object(V) -> equal(Slice(U,HPlace(V)),Place(U,V))**.
74[0:Inp] || OSPlace(U,Singleton(V),W)* Time(U) Object(V) -> equal(Place(U,V),W).
75[0:Inp] || equal(Place(U,V),W) Time(U) Object(V) -> OSPlace(U,Singleton(V),W)*.
76[0:Inp] || Leq3(U,V,W)* SkP4(X,Y,W,U)* -> Cavity(Slice(V,Y),Slice(V,X))*.
77[0:Inp] || ClosedContainer(U,V,W)* P(Place(U,X),W)* Object(X) -> CContained(U,X,V)*.
 This is a first-order Non-Horn problem containing equality.
 This is a problem that contains sort information.
 The conjecture is ground.
 The following monadic predicates have finite extensions: RigidObject.
 Axiom clauses: 76 Conjecture clauses: 1
 Inferences: IEmS=1 ISoR=1 IEqR=1 IEqF=1 ISpR=1 ISpL=1 IORe=1 IOFc=1 
 Reductions: RFRew=1 RBRew=1 RFMRR=1 RBMRR=1 RObv=1 RUnC=1 RTaut=1 RSSi=1 RFSub=1 RBSub=1 RAED=1 RCon=1 
 Extras    : Input Saturation, Dynamic Selection, Full Splitting, Full Reduction,  Ratio: 5, FuncWeight: 1, VarWeight: 1
 Precedence: skf3 > skf2 > skf1 > skf0 > Slice > Place > RUnion > HPlace > Singleton > Region > SkP0 > History > ObjectSet > SkP1 > CContained > ClosedContainer > OSPlace > Cavity > P > Object > Time > Ordered > Leq3 > Leq > Lt > RigidObject > RigidHistory > O > EC > DR > Outside > SkP2 > WeaklyContinuous > SkP4 > SkP3 > NoExitCavity > PersistentCavity > NoEntranceCavity > Continuous > Constant > skc6 > skc5 > skc4 > skc3 > skc2 > skc1 > skc0 > Hc1 > Tb1 > Ta1 > Ob1 > Ox1
 Ordering  : KBO
Processed Problem:

Worked Off Clauses:

Usable Clauses:
1[0:Inp] ||  -> RigidObject(Ob1)*.
2[0:Inp] ||  -> Lt(Ta1,Tb1)*.
5[0:Inp] ||  -> CContained(Ta1,Ox1,Singleton(Ob1))*.
4[0:Inp] RigidHistory(U) ||  -> History(U)*.
3[0:Inp] RigidObject(U) ||  -> Object(U)*.
19[0:Inp] ||  -> NoExitCavity(Ta1,Tb1,Hc1,HPlace(Ob1))*.
6[0:Inp] || CContained(Tb1,Ox1,Singleton(Ob1))* -> .
17[0:Inp] Object(U) ||  -> ObjectSet(Singleton(U))*.
18[0:Inp] Object(U) ||  -> History(HPlace(U))*.
16[0:Inp] || SkP1(U,V)* -> Region(U).
15[0:Inp] || SkP1(U,V)* -> Region(V).
14[0:Inp] || SkP0(U,V)* -> Region(U).
13[0:Inp] || SkP0(U,V)* -> Region(V).
12[0:Inp] || Ordered(U,V)* -> Time(V).
11[0:Inp] || Ordered(U,V)* -> Time(U).
8[0:Inp] || Lt(U,V)* -> Time(V).
7[0:Inp] || Lt(U,V)* -> Time(U).
10[0:Inp] || Leq(U,V)* -> Time(V).
9[0:Inp] || Leq(U,V)* -> Time(U).
28[0:Inp] || Outside(U,V) -> SkP1(V,U)*.
27[0:Inp] || Cavity(U,V) -> SkP1(V,U)*.
26[0:Inp] || DR(U,V) -> SkP0(V,U)*.
25[0:Inp] || EC(U,V) -> SkP0(V,U)*.
24[0:Inp] || O(U,V) -> SkP0(V,U)*.
23[0:Inp] || P(U,V) -> SkP0(V,U)*.
46[0:Inp] || equal(U,V) -> Leq(U,V)*.
45[0:Inp] || Lt(U,V) -> Leq(U,V)*.
30[0:Inp] || OSPlace(U,V,W)* -> ObjectSet(V).
37[0:Inp] || CContained(U,V,W)* -> ObjectSet(W).
33[0:Inp] || ClosedContainer(U,V,W)* -> ObjectSet(V).
43[0:Inp] || Constant(U,V,W)* -> History(W).
40[0:Inp] || SkP2(U,V,W)* -> History(U).
44[0:Inp] || CContained(U,V,W)* -> Object(V).
31[0:Inp] || OSPlace(U,V,W)* -> Region(W).
34[0:Inp] || ClosedContainer(U,V,W)* -> Region(W).
42[0:Inp] || Constant(U,V,W)* -> Time(V).
41[0:Inp] || Constant(U,V,W)* -> Time(U).
39[0:Inp] || SkP2(U,V,W)* -> Time(V).
38[0:Inp] || SkP2(U,V,W)* -> Time(W).
29[0:Inp] || OSPlace(U,V,W)* -> Time(U).
22[0:Inp] || Leq3(U,V,W)* -> Time(W).
21[0:Inp] || Leq3(U,V,W)* -> Time(V).
20[0:Inp] || Leq3(U,V,W)* -> Time(U).
35[0:Inp] || CContained(U,V,W)* -> Time(U).
32[0:Inp] || ClosedContainer(U,V,W)* -> Time(U).
51[0:Inp] ||  -> P(Slice(Tb1,HPlace(Ox1)),Slice(Tb1,Hc1))*.
53[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
52[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
50[0:Inp] || SkP3(U,V,W,X)* -> History(U).
49[0:Inp] || SkP3(U,V,W,X)* -> History(V).
48[0:Inp] || SkP3(U,V,W,X)* -> Time(W).
47[0:Inp] || SkP3(U,V,W,X)* -> Time(X).
54[0:Inp] || Continuous(U,V,W) -> SkP2(W,V,U)*.
55[0:Inp] || WeaklyContinuous(U,V,W) -> SkP2(W,V,U)*.
56[0:Inp] || SkP4(U,V,W,X)* -> Lt(X,W).
57[0:Inp] Region(U) Region(V) ||  -> Region(RUnion(V,U))*.
59[0:Inp] History(U) Time(V) ||  -> Region(Slice(V,U))*.
58[0:Inp] Object(U) Time(V) ||  -> Region(Place(V,U))*.
61[0:Inp] || Leq(U,V)* -> equal(U,V) Lt(U,V).
60[0:Inp] || SkP4(U,V,W,X)* -> WeaklyContinuous(X,W,V).
66[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
65[0:Inp] || NoExitCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
64[0:Inp] || PersistentCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
63[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
62[0:Inp] || NoExitCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
67[0:Inp] || ClosedContainer(U,V,W)* -> Cavity(W,skf2(W,X,Y))*.
68[0:Inp] || ClosedContainer(U,V,W) -> OSPlace(U,V,skf2(W,V,U))*.
69[0:Inp] || CContained(U,V,W) -> ClosedContainer(U,W,skf3(V,U,W))*.
70[0:Inp] || Leq(U,V) Leq(V,W) -> Leq3(U,V,W)*.
72[0:Inp] || CContained(U,V,W)* -> P(Place(U,V),skf3(V,U,X))*.
71[0:Inp] || Cavity(U,V)* OSPlace(W,X,V)* -> ClosedContainer(W,X,U)*.
73[0:Inp] Object(U) Time(V) ||  -> equal(Slice(V,HPlace(U)),Place(V,U))**.
78[0:MRR:74.0,29.1] Object(U) || OSPlace(V,Singleton(U),W)* -> equal(Place(V,U),W).
79[0:Res:77.3,6.0] Object(Ox1) || P(Place(Tb1,Ox1),U) ClosedContainer(Tb1,Singleton(Ob1),U)* -> .
75[0:Inp] Object(U) Time(V) || equal(Place(V,U),W) -> OSPlace(V,Singleton(U),W)*.
77[0:Inp] Object(U) || P(Place(V,U),W)* ClosedContainer(V,X,W)* -> CContained(V,U,X)*.
76[0:Inp] || Leq3(U,V,W)* SkP4(X,Y,W,U)* -> Cavity(Slice(V,Y),Slice(V,X))*.
	Given clause: 1[0:Inp] ||  -> RigidObject(Ob1)*.
	Given clause: 2[0:Inp] ||  -> Lt(Ta1,Tb1)*.
	Given clause: 5[0:Inp] ||  -> CContained(Ta1,Ox1,Singleton(Ob1))*.
	Given clause: 4[0:Inp] RigidHistory(U) ||  -> History(U)*.
	Given clause: 3[0:Inp] RigidObject(U) ||  -> Object(U)*.
	Given clause: 19[0:Inp] ||  -> NoExitCavity(Ta1,Tb1,Hc1,HPlace(Ob1))*.
	Given clause: 6[0:Inp] || CContained(Tb1,Ox1,Singleton(Ob1))* -> .
	Given clause: 17[0:Inp] Object(U) ||  -> ObjectSet(Singleton(U))*.
	Given clause: 18[0:Inp] Object(U) ||  -> History(HPlace(U))*.
	Given clause: 16[0:Inp] || SkP1(U,V)* -> Region(U).
	Given clause: 15[0:Inp] || SkP1(U,V)* -> Region(V).
	Given clause: 14[0:Inp] || SkP0(U,V)* -> Region(U).
	Given clause: 13[0:Inp] || SkP0(U,V)* -> Region(V).
	Given clause: 12[0:Inp] || Ordered(U,V)* -> Time(V).
	Given clause: 11[0:Inp] || Ordered(U,V)* -> Time(U).
	Given clause: 8[0:Inp] || Lt(U,V)* -> Time(V).
	Given clause: 80[0:Res:2.0,8.0] ||  -> Time(Tb1)*.
	Given clause: 7[0:Inp] || Lt(U,V)* -> Time(U).
	Given clause: 81[0:Res:2.0,7.0] ||  -> Time(Ta1)*.
	Given clause: 10[0:Inp] || Leq(U,V)* -> Time(V).
	Given clause: 9[0:Inp] || Leq(U,V)* -> Time(U).
	Given clause: 28[0:Inp] || Outside(U,V) -> SkP1(V,U)*.
	Given clause: 82[0:Res:28.1,15.0] || Outside(U,V)* -> Region(U).
	Given clause: 83[0:Res:28.1,16.0] || Outside(U,V)* -> Region(V).
	Given clause: 27[0:Inp] || Cavity(U,V) -> SkP1(V,U)*.
	Given clause: 84[0:Res:27.1,15.0] || Cavity(U,V)* -> Region(U).
	Given clause: 85[0:Res:27.1,16.0] || Cavity(U,V)* -> Region(V).
	Given clause: 26[0:Inp] || DR(U,V) -> SkP0(V,U)*.
	Given clause: 86[0:Res:26.1,13.0] || DR(U,V)* -> Region(U).
	Given clause: 25[0:Inp] || EC(U,V) -> SkP0(V,U)*.
	Given clause: 87[0:Res:26.1,14.0] || DR(U,V)* -> Region(V).
	Given clause: 88[0:Res:25.1,13.0] || EC(U,V)* -> Region(U).
	Given clause: 89[0:Res:25.1,14.0] || EC(U,V)* -> Region(V).
	Given clause: 24[0:Inp] || O(U,V) -> SkP0(V,U)*.
	Given clause: 23[0:Inp] || P(U,V) -> SkP0(V,U)*.
	Given clause: 90[0:Res:24.1,13.0] || O(U,V)* -> Region(U).
	Given clause: 91[0:Res:24.1,14.0] || O(U,V)* -> Region(V).
	Given clause: 92[0:Res:23.1,13.0] || P(U,V)* -> Region(U).
	Given clause: 93[0:Res:23.1,14.0] || P(U,V)* -> Region(V).
	Given clause: 46[0:Inp] || equal(U,V) -> Leq(U,V)*.
	Given clause: 96[0:AED:94.0] ||  -> Time(U)*.
	Given clause: 97[0:MRR:59.1,96.0] History(U) ||  -> Region(Slice(V,U))*.
	Given clause: 98[0:MRR:58.1,96.0] Object(U) ||  -> Region(Place(V,U))*.
	Given clause: 45[0:Inp] || Lt(U,V) -> Leq(U,V)*.
	Given clause: 30[0:Inp] || OSPlace(U,V,W)* -> ObjectSet(V).
	Given clause: 37[0:Inp] || CContained(U,V,W)* -> ObjectSet(W).
	Given clause: 102[0:Res:5.0,37.0] ||  -> ObjectSet(Singleton(Ob1))*.
	Given clause: 33[0:Inp] || ClosedContainer(U,V,W)* -> ObjectSet(V).
	Given clause: 43[0:Inp] || Constant(U,V,W)* -> History(W).
	Given clause: 40[0:Inp] || SkP2(U,V,W)* -> History(U).
	Given clause: 44[0:Inp] || CContained(U,V,W)* -> Object(V).
	Given clause: 103[0:Res:5.0,44.0] ||  -> Object(Ox1)*.
	Given clause: 31[0:Inp] || OSPlace(U,V,W)* -> Region(W).
	Given clause: 34[0:Inp] || ClosedContainer(U,V,W)* -> Region(W).
	Given clause: 51[0:Inp] ||  -> P(Slice(Tb1,HPlace(Ox1)),Slice(Tb1,Hc1))*.
	Given clause: 105[0:Res:51.0,93.0] ||  -> Region(Slice(Tb1,Hc1))*.
	Given clause: 106[0:Res:51.0,92.0] ||  -> Region(Slice(Tb1,HPlace(Ox1)))*.
	Given clause: 53[0:Inp] || Leq3(U,V,W)* -> Leq(V,W).
	Given clause: 52[0:Inp] || Leq3(U,V,W)* -> Leq(U,V).
	Given clause: 50[0:Inp] || SkP3(U,V,W,X)* -> History(U).
	Given clause: 49[0:Inp] || SkP3(U,V,W,X)* -> History(V).
	Given clause: 54[0:Inp] || Continuous(U,V,W) -> SkP2(W,V,U)*.
	Given clause: 107[0:Res:54.1,40.0] || Continuous(U,V,W)* -> History(W).
	Given clause: 55[0:Inp] || WeaklyContinuous(U,V,W) -> SkP2(W,V,U)*.
	Given clause: 56[0:Inp] || SkP4(U,V,W,X)* -> Lt(X,W).
	Given clause: 108[0:Res:55.1,40.0] || WeaklyContinuous(U,V,W)* -> History(W).
	Given clause: 57[0:Inp] Region(U) Region(V) ||  -> Region(RUnion(V,U))*.
	Given clause: 61[0:Inp] || Leq(U,V)* -> equal(U,V) Lt(U,V).
	Given clause: 60[0:Inp] || SkP4(U,V,W,X)* -> WeaklyContinuous(X,W,V).
	Given clause: 99[0:MRR:73.1,96.0] Object(U) ||  -> equal(Slice(V,HPlace(U)),Place(V,U))**.
	Given clause: 115[0:SSi:113.0,103.0] ||  -> P(Place(Tb1,Ox1),Slice(Tb1,Hc1))*.
	Given clause: 117[0:Res:115.0,92.0] ||  -> Region(Place(Tb1,Ox1))*.
	Given clause: 67[0:Inp] || ClosedContainer(U,V,W)*+ -> Cavity(W,skf2(W,X,Y))*.
	Given clause: 66[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
	Given clause: 65[0:Inp] || NoExitCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
	Given clause: 119[0:Res:66.1,56.0] || NoEntranceCavity(U,V,W,X)* -> Lt(U,V).
	Given clause: 121[0:Res:65.1,56.0] || NoExitCavity(U,V,W,X)* -> Lt(U,V).
	Given clause: 118[0:Res:66.1,60.0] || NoEntranceCavity(U,V,W,X)* -> WeaklyContinuous(U,V,W).
	Given clause: 120[0:Res:65.1,60.0] || NoExitCavity(U,V,W,X)* -> WeaklyContinuous(U,V,W).
	Given clause: 64[0:Inp] || PersistentCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
	Given clause: 123[0:Res:19.0,120.0] ||  -> WeaklyContinuous(Ta1,Tb1,Hc1)*.
	Given clause: 126[0:Res:123.0,108.0] ||  -> History(Hc1)*.
	Given clause: 124[0:Res:64.1,49.0] || PersistentCavity(U,V,W,X)* -> History(W).
	Given clause: 125[0:Res:64.1,50.0] || PersistentCavity(U,V,W,X)* -> History(X).
	Given clause: 63[0:Inp] || NoEntranceCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
	Given clause: 127[0:Res:63.1,49.0] || NoEntranceCavity(U,V,W,X)* -> History(W).
	Given clause: 128[0:Res:63.1,50.0] || NoEntranceCavity(U,V,W,X)* -> History(X).
	Given clause: 62[0:Inp] || NoExitCavity(U,V,W,X) -> SkP3(X,W,V,U)*.
	Given clause: 129[0:Res:62.1,49.0] || NoExitCavity(U,V,W,X)* -> History(W).
	Given clause: 70[0:Inp] || Leq(U,V) Leq(V,W) -> Leq3(U,V,W)*.
	Given clause: 130[0:Res:62.1,50.0] || NoExitCavity(U,V,W,X)* -> History(X).
	Given clause: 134[0:Res:19.0,130.0] ||  -> History(HPlace(Ob1))*.
	Given clause: 104[0:MRR:79.0,103.0] || P(Place(Tb1,Ox1),U) ClosedContainer(Tb1,Singleton(Ob1),U)* -> .
	Given clause: 68[0:Inp] || ClosedContainer(U,V,W) -> OSPlace(U,V,skf2(W,V,U))*.
	Given clause: 69[0:Inp] || CContained(U,V,W) -> ClosedContainer(U,W,skf3(V,U,W))*.
	Given clause: 135[0:Res:68.1,31.0] || ClosedContainer(U,V,W) -> Region(skf2(W,V,U))*.
	Given clause: 138[0:Res:69.1,34.0] || CContained(U,V,W) -> Region(skf3(V,U,W))*.
	Given clause: 72[0:Inp] || CContained(U,V,W)*+ -> P(Place(U,V),skf3(V,U,X))*.
	Given clause: 141[0:Res:5.0,72.0] ||  -> P(Place(Ta1,Ox1),skf3(Ox1,Ta1,U))*.
	Given clause: 71[0:Inp] || Cavity(U,V)* OSPlace(W,X,V)*+ -> ClosedContainer(W,X,U)*.
	Given clause: 143[0:Res:141.0,92.0] ||  -> Region(Place(Ta1,Ox1))*.
	Given clause: 142[0:Res:141.0,93.0] ||  -> Region(skf3(Ox1,Ta1,U))*.
	Given clause: 78[0:MRR:74.0,29.1] Object(U) || OSPlace(V,Singleton(U),W)* -> equal(Place(V,U),W).
	Given clause: 100[0:MRR:75.1,96.0] Object(U) || equal(Place(V,U),W) -> OSPlace(V,Singleton(U),W)*.
	Given clause: 77[0:Inp] Object(U) || P(Place(V,U),W)*+ ClosedContainer(V,X,W)* -> CContained(V,U,X)*.
	Given clause: 153[0:SSi:151.0,103.0] || ClosedContainer(Tb1,U,Slice(Tb1,Hc1))* -> CContained(Tb1,Ox1,U).
	Given clause: 146[0:Res:100.2,31.0] Object(U) || equal(Place(V,U),W)*+ -> Region(W)*.
	Given clause: 154[0:SSi:152.0,103.0] || ClosedContainer(Ta1,U,skf3(Ox1,Ta1,V))* -> CContained(Ta1,Ox1,U).
	Given clause: 140[0:Res:69.1,104.1] || CContained(Tb1,U,Singleton(Ob1)) P(Place(Tb1,Ox1),skf3(U,Tb1,Singleton(Ob1)))* -> .
	Given clause: 76[0:Inp] || Leq3(U,V,W)* SkP4(X,Y,W,U)*+ -> Cavity(Slice(V,Y),Slice(V,X))*.
	Given clause: 144[0:Res:68.1,71.1] || ClosedContainer(U,V,W) Cavity(X,skf2(W,V,U))* -> ClosedContainer(U,V,X).
	Given clause: 137[0:Res:69.1,67.0] || CContained(U,V,W) -> Cavity(skf3(V,U,W),skf2(skf3(V,U,W),X,Y))*.
	Given clause: 159[0:Res:137.1,85.0] || CContained(U,V,W) -> Region(skf2(skf3(V,U,W),X,Y))*.
	Given clause: 145[0:Res:68.1,78.1] Object(U) || ClosedContainer(V,Singleton(U),W) -> equal(skf2(W,Singleton(U),V),Place(V,U))**.
	Given clause: 148[0:Res:100.2,71.1] Object(U) || equal(Place(V,U),W)*+ Cavity(X,W)* -> ClosedContainer(V,Singleton(U),X)*.
	Given clause: 171[0:EqR:148.1] Object(U) || Cavity(V,Place(W,U)) -> ClosedContainer(W,Singleton(U),V)*.
	Given clause: 178[0:SSi:175.0,3.0,1.1] || Cavity(U,Place(Tb1,Ob1))* P(Place(Tb1,Ox1),U) -> .
	Given clause: 172[0:Res:171.2,67.0] Object(U) || Cavity(V,Place(W,U))*+ -> Cavity(V,skf2(V,X,Y))*.
	Given clause: 176[0:Res:171.2,153.0] Object(U) || Cavity(Slice(Tb1,Hc1),Place(Tb1,U))* -> CContained(Tb1,Ox1,Singleton(U)).
	Given clause: 157[0:Res:65.1,76.1] || NoExitCavity(U,V,W,X)*+ Leq3(U,Y,V)* -> Cavity(Slice(Y,W),Slice(Y,X))*.
	Given clause: 179[0:Res:19.0,157.0] || Leq3(Ta1,U,Tb1) -> Cavity(Slice(U,Hc1),Slice(U,HPlace(Ob1)))*.
	Given clause: 182[0:Res:179.1,84.0] || Leq3(Ta1,U,Tb1) -> Region(Slice(U,Hc1))*.
	Given clause: 181[0:Res:179.1,85.0] || Leq3(Ta1,U,Tb1) -> Region(Slice(U,HPlace(Ob1)))*.
	Given clause: 183[0:SSi:180.0,3.0,1.1] || Leq3(Ta1,U,Tb1) -> Cavity(Slice(U,Hc1),Place(U,Ob1))*.
	Given clause: 158[0:Res:66.1,76.1] || NoEntranceCavity(U,V,W,X)*+ Leq3(U,Y,V)* -> Cavity(Slice(Y,W),Slice(Y,X))*.
	Given clause: 190[0:MRR:188.1,115.0] || Leq3(Ta1,Tb1,Tb1)* -> .
	Given clause: 192[0:Res:70.2,190.0] || Leq(Ta1,Tb1) Leq(Tb1,Tb1)* -> .
	Given clause: 195[0:Obv:194.0] || Leq(Ta1,Tb1)* -> .
SPASS V 3.7 
SPASS beiseite: Proof found.
Problem: inference1_p4.dfg 
SPASS derived 105 clauses, backtracked 0 clauses, performed 0 splits and kept 154 clauses.
SPASS allocated 52414 KBytes.
SPASS spent	0:00:00.07 on the problem.
		0:00:00.03 for the input.
		0:00:00.02 for the FLOTTER CNF translation.
		0:00:00.00 for inferences.
		0:00:00.00 for the backtracking.
		0:00:00.00 for the reduction.


Here is a proof with depth 7, length 42 :
1[0:Inp] ||  -> RigidObject(Ob1)*.
2[0:Inp] ||  -> Lt(Ta1,Tb1)*.
3[0:Inp] RigidObject(U) ||  -> Object(U)*.
5[0:Inp] ||  -> CContained(Ta1,Ox1,Singleton(Ob1))*.
6[0:Inp] || CContained(Tb1,Ox1,Singleton(Ob1))* -> .
9[0:Inp] || Leq(U,V)* -> Time(U).
19[0:Inp] ||  -> NoExitCavity(Ta1,Tb1,Hc1,HPlace(Ob1))*.
44[0:Inp] || CContained(U,V,W)* -> Object(V).
45[0:Inp] || Lt(U,V) -> Leq(U,V)*.
46[0:Inp] || equal(U,V) -> Leq(U,V)*.
51[0:Inp] ||  -> P(Slice(Tb1,HPlace(Ox1)),Slice(Tb1,Hc1))*.
65[0:Inp] || NoExitCavity(U,V,W,X) -> SkP4(X,W,V,U)*.
70[0:Inp] || Leq(U,V) Leq(V,W) -> Leq3(U,V,W)*.
71[0:Inp] || Cavity(U,V)* OSPlace(W,X,V)*+ -> ClosedContainer(W,X,U)*.
73[0:Inp] Object(U) Time(V) ||  -> equal(Slice(V,HPlace(U)),Place(V,U))**.
75[0:Inp] Object(U) Time(V) || equal(Place(V,U),W) -> OSPlace(V,Singleton(U),W)*.
76[0:Inp] || Leq3(U,V,W)* SkP4(X,Y,W,U)*+ -> Cavity(Slice(V,Y),Slice(V,X))*.
77[0:Inp] Object(U) || P(Place(V,U),W)*+ ClosedContainer(V,X,W)* -> CContained(V,U,X)*.
79[0:Res:77.3,6.0] Object(Ox1) || P(Place(Tb1,Ox1),U) ClosedContainer(Tb1,Singleton(Ob1),U)* -> .
94[0:Res:46.1,9.0] || equal(U,V)* -> Time(U)*.
96[0:AED:94.0] ||  -> Time(U)*.
99[0:MRR:73.1,96.0] Object(U) ||  -> equal(Slice(V,HPlace(U)),Place(V,U))**.
100[0:MRR:75.1,96.0] Object(U) || equal(Place(V,U),W) -> OSPlace(V,Singleton(U),W)*.
103[0:Res:5.0,44.0] ||  -> Object(Ox1)*.
104[0:MRR:79.0,103.0] || P(Place(Tb1,Ox1),U) ClosedContainer(Tb1,Singleton(Ob1),U)* -> .
113[0:SpR:99.1,51.0] Object(Ox1) ||  -> P(Place(Tb1,Ox1),Slice(Tb1,Hc1))*.
115[0:SSi:113.0,103.0] ||  -> P(Place(Tb1,Ox1),Slice(Tb1,Hc1))*.
148[0:Res:100.2,71.1] Object(U) || equal(Place(V,U),W)*+ Cavity(X,W)* -> ClosedContainer(V,Singleton(U),X)*.
157[0:Res:65.1,76.1] || NoExitCavity(U,V,W,X)*+ Leq3(U,Y,V)* -> Cavity(Slice(Y,W),Slice(Y,X))*.
171[0:EqR:148.1] Object(U) || Cavity(V,Place(W,U)) -> ClosedContainer(W,Singleton(U),V)*.
175[0:Res:171.2,104.1] Object(Ob1) || Cavity(U,Place(Tb1,Ob1))* P(Place(Tb1,Ox1),U) -> .
178[0:SSi:175.0,3.0,1.1] || Cavity(U,Place(Tb1,Ob1))* P(Place(Tb1,Ox1),U) -> .
179[0:Res:19.0,157.0] || Leq3(Ta1,U,Tb1) -> Cavity(Slice(U,Hc1),Slice(U,HPlace(Ob1)))*.
180[0:SpR:99.1,179.1] Object(Ob1) || Leq3(Ta1,U,Tb1) -> Cavity(Slice(U,Hc1),Place(U,Ob1))*.
183[0:SSi:180.0,3.0,1.1] || Leq3(Ta1,U,Tb1) -> Cavity(Slice(U,Hc1),Place(U,Ob1))*.
188[0:Res:183.1,178.0] || Leq3(Ta1,Tb1,Tb1) P(Place(Tb1,Ox1),Slice(Tb1,Hc1))* -> .
190[0:MRR:188.1,115.0] || Leq3(Ta1,Tb1,Tb1)* -> .
192[0:Res:70.2,190.0] || Leq(Ta1,Tb1) Leq(Tb1,Tb1)* -> .
194[0:Res:46.1,192.1] || equal(Tb1,Tb1) Leq(Ta1,Tb1)* -> .
195[0:Obv:194.0] || Leq(Ta1,Tb1)* -> .
196[0:Res:45.1,195.0] || Lt(Ta1,Tb1)* -> .
198[0:MRR:196.0,2.0] ||  -> .
Formulae used in the proof : axiom21 axiom23 axiom17 axiom22 conjecture0 axiom1 axiom20 axiom28 axiom29 axiom19 axiom24 axiom30 axiom27 axiom25 axiom26

--------------------------SPASS-STOP------------------------------
